# [一名一线开发对于App架构和组件化的思考](https://mp.weixin.qq.com/s/c8IRs-Tt6EQN8TT4gVR6yg) 一文阅读笔记

> 名词解释：本文中所提到的架构不是实际工程中代码架构（MVC、MVVM、MVP），确切的说是一种**应用分层架构**。而MVC、MVVM、MVP本质是一种软件架构模式，是App实现过程中的一种**编码模式或者编码规范**。

Note: 萌新如我依旧站在比较低的层次去看待架构，往往只能扯扯MVC、MVVM、MVP以及一些设计模式，正如作者所说的这只是一种编码规范，或者说是套一个模板——设计模式也一样，但往往实际开发中我做的并不太好。

如果站得再高一些些，就是应用分层架构，比如哪些是基础库（通信模块、缓存模块），哪些是业务基础库，哪些是业务模块，分清楚后就是解决问题，显然把所有东西放在一起是没问题，但是随着不断迭代更新，问题会接踵而至，所以提前分层就非常必要，可能会提高学习成本，但是之后维护会相对轻松一些，另外要说一点，分层了不一定会提高效率，还得取决于实际项目，不断调整、适配以达到一个最优支点。

继续看下作者对于iOS系统架构回顾：

![](https://mmbiz.qpic.cn/mmbiz/foPACGrddJ1Ibkwic5BwK3hgDUuTbqqwXWm6ZHyw30OpwvQrNtIQI1DwD4ekQ1sLpkbIVW6CjkPVib8Iw1Ticdb2w/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)

如上图所示，经典的iOS系统架构分为四层，自下而上分为核心操作系统层、核心服务层、媒体层、用户交互层。

- **Cocoa Touch**：提供与用户交互的相关能力，包括触摸等，最常用的UIKit库就在该层；除此之外还有MapKit、Address BookUI、PhotosUI等。
- **Media Layer**：提供图形与音视频相关功能的接口，例如Core Animation、OpenGL ES等。
- **Core Services**：最常用的有Core Foundation、Foundation、CFNetwork、CoreData等。提供最基础的能力，比如数组、字典、HashMap、套接字等基础数据结构。
- **Core OS**：包含Mach、Kernel、BSD、Socket以及Sandbox等，它主要提供了底层操作的接口，对于应用开发来讲直接用到的不是很多。

不是我关注的重点，暂且摘抄下即可。

> Q：iOS系统架构这四层之间是如何进行通信和交互的，是否合理？
>
> A：直接引用头文件，调用下层提供的Api进行交互。关于是否合理，我想说的是只要Api设计的足够合理，足够能应对未来一段时间内SDK内部可能的变动，或者说SDK本身是一个很基础的库，比如Foundation库等，我觉得直接引入头文件无伤大雅，具体的我们稍后再讨论。

这个我非常认同，作为基础库自然是以 import 的形式导入；但有时候为了解耦，比如CTMediator是借助 runtime 的反射，我们可以做到只导入一个 CTMediator.h 就可以，但为此付出的代价就是需要使用字符串硬编码就调用接口，当然之后Casa也说到了，这个问题也好解决，我们只需要对CTMediator进行category就可以啦，分类里会明确API接口，接口作用和参数都非常明确，但仔细一想，这种做法前提就是堆模块封装极好，然后开放一个接口的头文件出来，调用方想要使用时就import就ok了，本质还是一样的。



## **设计一个合理的应用分层架构**

作者以盖楼比喻，但是我觉得似乎不是很恰当，先贴下出来：

- 第一步：打地基、支模板、浇灌水泥搭架子、搬砖垒墙，这是一切的基础，高楼要屹立不倒，需要这些模块的长久有力的支撑才行。抽象到应用架构里面，我们称之为**基础模块**，其主要提供应用最基础的能力。

- 第二步：铺地面、造门，其中门在卧室、餐厅都可能会用到。抽象到应用架构里面，我们称之为**公共业务模块**，它主要提供了一些通用的业务模块或者通用的组件。

- 第三步：给大楼赋能，卧室、餐厅、洗漱间等一应俱全，有了这些才能真正体现盖大楼的意义。卧室等功能都要用到砖、墙、门等基础模块。在应用架构中，我们把卧室、厨房、洗漱等独立功能抽象为**普通业务模块**，每个业务模块都代表一个具体的功能，业务模块间没有强关联关系。

我的简单理解，可能不是很准确：

* 基础模块这个就是**稳定和业务无关**的，比如网络库，数据序列化库，JSBridge，数据库存储等等，而平常我们使用的Pods，比如SDWebImage、AFN等应该都是基础库，而对于其他一些某些业务需求用到的Pods我觉得不应该划到这里，原因是不太稳定，随时可能被剥离替换，可以放到公共业务模块？
* 公共业务模块正如上面所说的就是一些通用的业务模块，比如带有一些公司定制化的分享弹窗组件，股票公司的分时K线图，搜索模块等
* 普通业务就是我们平常开发的需求；

![](https://mmbiz.qpic.cn/mmbiz/foPACGrddJ1Ibkwic5BwK3hgDUuTbqqwXSSSm1kkEOOd5NPYAvpY15XE2vfUpK2oLMlENZ9ucY2sax57OAVcVPw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)

## **应用架构实施落地**

下面这张图划分很赞：

![](https://mmbiz.qpic.cn/mmbiz/foPACGrddJ1Ibkwic5BwK3hgDUuTbqqwXU6ibicwOlVQia7DaGpFfIGq8eoLvJpn9n2NaphaTxz9HwMKQxjfWweibkg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)

- **基础模块**：因模块高度独立，且高频使用，若公司内部有多个App同时需要依赖，建议单独创建私有库Specs。
- **公共业务模块**：功能相对独立，根据业务需求来决定是否单独创建私有库Specs。
- **Cocoapods公有库**：所有公司内部App，强烈建议不要直接引入公有Specs。这样做有两点好处：
  1.跟外部环境有效隔离，第三方库发生问题，公司内部可控。
  2.公有库太大，每次repo update耗时太长，国内的环境你懂的，没有科学上网，至少一个小时过去repo也未必更新完毕。所以通用的方案是，若公司内部引用了第三方库，按照依赖倒置的原则，建议封装一层之后放到**Basic Specs**供业务方使用。

作者的 QA 还是不错的。

Q：如何把握组件拆分粒度？
A：没有一个可衡量的标准，需要结合具体业务场景，那些复用性高、功能相对独立就可以考虑做拆分。还有需要注意的是，组件拆分不一定要抽离成pod库，可以将有一定特性的**一组通用组件**打成一个pod库（姑且定义成CommonUIKit）。我们知道pod库最终都是生成静态库引用到主工程的，也就是最终都会经过链接的过程，pod库过多会带来一定的App启动性能开销，其次pod库过多也会导致pod管理混乱的问题。

> 有个问题，Pod还需要重新编译吗？还是说只需要作为静态库在编译最后做下链接就可以？？ 这个问题得搞清楚。



Q：比如一个很小的功能，就一个弹框我需要去做解耦么，我抽成pod库别人直接引用不就得了？
A：在回答之前，我们先思考两个问题。弹框组件未来变动可能性有多大？你设计的Api是否合理，是否能够满足未来产品的需求？第二个问题，解耦带来的益处能够cover住这些可能的变动带来的弊端？想清楚这两个问题，我们就知道设计一个组件是否需要做解耦，是否需要用中间服务去除依赖了。



## 关于耦合问题

想要使用其他通用模块提供的功能，必定需要导入依赖，比如在首页使用登陆功能，那头文件就需要把登陆模块的头文件导入进来，然后调用它开放的API，但是这样有个问题，随着首页集成的功能越来越多，依赖也就越来越多，而且不只是首页，其他页面同样如此，此时需要解决这个难题，引入中间者即可。

> 当然也会有人像我一样纠结，什么时候用中间者来进行模块之间的server communication，对于Masonry，AFN等基础库直接导入就可以，这个毫无疑问。



Q：我该如何设计一个路由，用于模块间的跳转？

A：设计路由需要遵循几个原则。

第一，便于集成，最小的改动即可实现一个路由。
第二，最大限度把参数正确性校验提前，能在编译时校验就不要在运行时校验。
第三，尽可能的支持多种注册方式，**静态注册、动态注册**、服务配置等。